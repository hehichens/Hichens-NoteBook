## 1. 存储器概述

### 1.1 存储器分类

#### 1.1.1 存储介质

- 半导体存储器：用MOS管制成
- 磁表面存储器：用磁性材料制成
- 光盘存储器：用光介质制成



#### 1.1.2 存取方式（依赖存储单元的物理位置）

- 随机存储器
- 顺序存储器
- 半顺序存储器：存取时间部分依赖（磁盘）



#### 1.1.3 存储内容是否可变

- 只读存储器（ROM）
- 随机读写存储器（RAM）



#### 1.1.4 在计算机系统的作用

- 辅助存储器（磁盘）
  - 不能被直接CPU访问
  - 保存系统所有的数据和程序
- 主存储器（半导体存储器）
  - 能被直接CPU访问
  - 保存系统当前的数据和程序
- 高速缓冲存储器（Cache）
  - 保存系统运行时频繁访问的数据和程序
- 控制存储器（寄存器）
  - CPU内部存储单元



### 1.2 存储器分级

![](./pic/1.png)

在CPU看来， 容量相当于辅存容量， 速度相当于CACHE速度。



分级应该解决的问题（由操作系统解决）

- 精确定位辅存中的指定内容调入主存

- CPU访问cache时出现未命中情况

### 1.3 存储器指标

#### 1.3.1 存储容量

- 存储器能否存放的二进制数据的总数

- 存储容量=存储段元个数 × 存储字长（单位：位）

#### 1.3.2 存储速度

- 存取时间
  - 一次操作所用的时间
  - 单位ns，分读出和写入时间
- 存取周期
  - 两次操作之间所需最小的时间间隔
  - 单位ns，存取周期=存取时间+复原时间
- 存储器带宽
  - 每秒存储器进出的最大信息数量
  - 单位：位/秒、字节/秒， 存储带宽=每周期信息量/周期时长

## 2. SRAM（静态RAM）

### 2.0 主存储器的构成

- SRAM
  - MOS电路构成的双稳触发器
  - 速度快，但造价高、功耗大、集成度低
- DRAM
  - MOS电路构成的栅极电容
  - 集成度高、功耗小、价格低，但速度慢

### 2.1 SRAM元阵列

- 基本存储单元
  - 6个MOS管构成一个存储元
  - 存储元为非易失性
- 3种外部信号线
  - 地址线，n根地址线有2^n个单元
  - 数据线，m根数据线对应的单元为m位
  - 控制线：读写控制信号R/W，1位读，0为写



### 2.2 SRAM逻辑结构

#### 2.2.1 译码驱动方式

- 单译码：适用较小的存储器
- 双译码：被选单元由X、Y两个方向的地址决定

#### 2.2.2 组成结构

- 存储体
  - 存储段远集合，按位将存储单元组织成存储矩阵
- 地址译码器
  - 将CPU发出的地址信息转成存储元选通信号
- 译码驱动器
  - X选择线上用于增强驱动能力的电路
- I/O电路
  - 读写电路和放大电路
- 片选
  - CPU选芯片
- 读/写读写控制电路
  - 对存储单元读或写
- 输出驱动电路
  - 增强数据总线的驱动能力

### 2.3 存储容量的扩充

#### 2.3.1 存储芯片和CPU的引脚

- 数据总线
  - 位数与存储单元字长相同，用于传送数据信息
- 地址总线
  - 存储元单元个数=2^n位数，用于选择存储单元
- 读写信号WE
  - 访问类型：读或写
- 片选信号CS
  - 决定当前芯片是否被访问

#### 2.3.2 位拓展

- 存储单元数不变，增加单元位数
- 引脚连接方法
  - 地址线：直接相连
  - 数据线：各芯片的数据线连接CPU不同位的数据线
  - 片选与读写信号：直接相连
- CPU对该存储器的访问是对**各位扩展芯片的同一单元**的同时访问

#### 2.3.3 字拓展

- 单元位数不变，总单元个数增加
- 引脚连接方法：
  - 地址线：芯片的地址线与CPU的低位地址线相连
  - 数据线：直接相连
  - 读写信号：直接相连
  - 片选信号：芯片的片选信号由CPU的高位地址线和访存信号产生
- CPU对该存储器的访问是对**某一字扩展芯片的一个单元**的访问

#### 2.3.4 字位拓展

1. 位拓展，得到满足位需求的存储芯片组
2. 字拓展，使用存储芯片组进行字拓展



## 3. 其他存储器

### 3.1 只读存储器（ROM）

- 掩模式ROM：数据制造时集中写入，不能更改
- 一次性ROM（PROM）：用户第一次使用时写入确定内容
- 多次编程ROM：可用紫外线照射（EPROM）或电擦除（EEPROM）多次改写内容

### 3.2 闪速存储器（Flash Memory）

- 在EPROM的基础上，增加电路擦除和重新编程能力
- U盘属于闪存存储器

### 3.3 高速存储器

#### 3.3.1 双端口存储器

- 采用空间并行技术
  - 同一存储体使用互相独立的读写控制线路，并行操作。
- 显卡存储器一般是双端口存储器
- 读写特点
  - 无冲突读写：访问不同存储单元，可并行读写存储体
  - 有冲突读写：访问同一存储单元，可用BUSY信号控制读写有按顺序

#### 3.3.2 多模块交叉存储器

- 采用时间并行技术
- 模块化组织方式
  - 顺序方式：直接增添模块来增加容量；但是各模块是串行工作，限制了带宽
  - 交叉方式：块数据传送时，大大提高了带宽；但是模块间依赖性高，不易进行容量扩充。
- CPU多多模块同时访问



## 4. Cache存储器:star2:

### 4.1 Cache 基本原理

#### 4.1.1 使用Cache

- 原因：解决主存与CPU速度差距过大的原因
- 作用：在CPU与主存间加SRAM（Cache），主存中将要被访问的数据提前送到Cache，CPU访问主存时，先访问Cache，未命中再作调整。
- 依据：程序访问的局部性原理

#### 4.1.2 Cache基本设计思想

- 结构模块化
  - CPU访问Cache或主存，以字节为单位
  - Cache与主存交换信息，以块（若干个字构成）为单位
  - Cache每行都设有标记，CPU访问数据前先访问标记
- 此结构全部由硬件实现
- Cache对程序员透明

#### 4.1.3 Cache基本构成

- 存储体：字为基本单位，若干字构成数据块
- 地址映射变换机构：将主存地址转为Cache地址
- 替换机构：更新Cache时使用
- 相联存储器：Cache块表，指示CPU要访问的信息是否在Cache中
- 读写控制

#### 4.1.4 Cache读写操作

以读操作为例

1. CPU发出有效主存地址
2. 经地址变化机构，变换为可能的Cache地址
3. 查块表，判断所访问信息是否在Cache中
4. 若在，CPU直接读取Cache信息
5. 若不在，CPU访问主存，并判断Cache是否已满

<img src="https://img-blog.csdn.net/20180620112326635?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTE0MTQ2MTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom:75%;" />

#### 4.1.5 Cache命中率

命中率

<img src="https://img-blog.csdnimg.cn/20200608201210112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3NjMx,size_16,color_FFFFFF,t_70" style="zoom:80%;" />

平均访问时间

<img src="https://img-blog.csdnimg.cn/20200608201858142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3NjMx,size_16,color_FFFFFF,t_70" style="zoom:80%;" />

访问效率

<img src="https://img-blog.csdnimg.cn/20200608203451219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3NjMx,size_16,color_FFFFFF,t_70" style="zoom:80%;" />



### 4.2 主存与Cache地址映射:star:

预备知识

- Cache与主存之间以块为单元进行数据交换，Cache中的块称为“行”，Cache的行与主存的块存储容量相同
- 相联存储表（CAM）是一种按内容寻址的存储器，tag存储于CAM中
- Cache中的标记tag与Cache中的行一一对应，如果一块主存数据拷贝到Cache的某行，该行就会形成对应的tag

#### 4.2.1 全相联映射

- 主存中的任意字块可以任意调入Cache中的任一行
- 设主存共2^n个单元， 分成2^m个块， 每块单元数为2^b个
  - 主存地址格式：主存块号（m） + 块内偏移地址（b）
  - Cache地址格式：Cache行号（c）+ 行内偏移地址（b）
- 主存的数据块调入Cache后，该块的块号（主存块号）保存于对应Cache行的标记位（块表中）
  - 块表大小：2^c × m

#### 4.2.2 直接映射

- 主存中的每块数据只能调入Cache的特定行

- i = j mod 2^c，c是Cache行地址的位数

- 设主存共2^n个单元， 分成2^m个块， 每块单元数为2^b个

  - 主存地址
    - 主存块号（m） + 块内偏移地址（b）
    - 主存标记（t）+ Cache行号（c） + 块内偏移地址(b)
  - Cache地址格式：Cache行号（c）+ 行内偏移地址（b）

- 主存会与Cache行的关系

  - 主存的（ 2^m/ 2^c） = 2^(m-c)个块映射于Cache的同一行
  - 主存中的c决定该块对应cache行，t为主存标记
  - 块表大小：2^c × t

<img src="https://img-blog.csdn.net/20171207102107673" style="zoom:75%;" />

#### 4.2.3 组相联映射

- 将cache的空间分为若干组，主存块与cache组之间直接映射
- 设Cache共u组， 每组v行， 则映射函数如下
  - 组号 q= j mod u
- 地址
  - 主存地址格式：
    - 主存组号 + 组内块号 + 块内偏移地址
  - cache地址格式： cache组号+组内行号+行内偏移地址
  - Cache标记tag：组号



## 5. Cache替换策略

- 最不经常使用算法（LFU）
  - 替换一段时间内被访问次数最少的那行数据
- 近期最少使用算法（LRU）
  - 替换近期内长久未被访问过的行
- 随机替换算法

## 6. Cache写策略

### 3.1 写回式

策略

- 只修改Cache内容，而不立即修改主存内容
- 此行换出时才写回主存

优缺点

- 优点：减少了访问主存次数
- 缺点：存在Cache与主存内容不一致隐患

### 3.2 全写式

策略

- Cache与主存同时修改

### 3.3 写一次式

策略

- 融合写回式和全写式
- 第一次写命中时要同时写入主存









