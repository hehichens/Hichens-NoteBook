[TOC]

## 1. 大小写互换

```assembly
.486
data segment use16
    alpha db 'd'
data ends

code segment use16
assume cs:code, ds:data
    beg:mov ax, data
        mov ds, ax
        mov dl, alpha
        sub dl, 20H ; 'a'-'A'; or add 'A'-'a'
        mov ah, 2
        int 21H
        mov ah, 4CH
        int 21H
code ends
end beg
```



## 2. 二进制数转十六进制数

在文本方式下送往屏幕显示的任何字符都必须是该字符的ASCII码。
4位二进制数其等值的十六进制数及其ASCII码有如下关系：
4位二进制数： 			0000 	0001, …, 1001, 1010,…, 1111
等值的十六进制数： 	0 			1     …	9 		A	...		 F
十六进制数的ASCII： 30H 		31H … 39H 	41H …	 46H

- 当4位二进制数等于0000~0001时，该数加上30H就等于相应的十进制数的ASCII; 

- 当4位二进制数等于1010～1111时，该数加上37H就等于相应的十六进制数的ASCII码

```assembly
.486
data segment use16
bnum DW 0001001000110100B ;1234H
    DW 0101011001111000B ;5678H
    DW 0001101000101011B ;1A2BH
    DW 0011110001001101B ;3C4DH
buf db 4 dup(?), 'H $'
count db 4
data ends

code segment use16
	assume cs:code, ds:data
	beg:mov ax, data
		mov ds, ax
		mov cx, 4
		mov bx, offset bnum
	again:mov dx, [bx]
		sal edx, 16; 高16位与低16位互换，否则后面4位4位
								;隔离的时会破坏数据
		call N2_16
		mov ah, 9
		mov dx, offset buf
		int 21H
		add bx, 2
		loop again
		mov ah, 4CH
		int 21H
			
	;-----------------------
	N2_16 proc
		mov si, offset buf
		mov count, 4
	last:rol edx, 4
		and dl, 0FH ; mask operate 
		cmp dl, 10
		jc next
		add dl, 7
	next:add dl, 30H
		mov [si], dl
		inc si
		dec count
		jnz last
		ret
	N2_16 endp
	;-----------------------
	
code ends
end beg	
```



## 3. 二进制转十进制

首先把待转换的二进制数除以10, 余数压入堆栈, 再把商值除以10, 余数压栈,…, 直到商是0时为止.接下来依次从堆栈中弹出各次的余数,每弹出一个数就转换成ASCII
码送屏幕显示

```assembly
.486 
code segment use16
    assume cs:code
    num32 dd 3456789000
    beg:mov eax, num32
        mov ebx, 10
        mov cx, 0
    last:mov edx, 0
        div ebx
        push dx
        inc cx
        cmp eax, 0
        jnz last
    aga:pop dx
        add dl, 30H
        mov ah, 2
        int 21H
        loop aga
        mov ah, 4CH; return 
        int 21H
code ends
end beg
```



## 4. 整数开平方

求正整数N的开平方近似值

N的平方近似值等于N依次减去前ⅰ 个奇数, 一直到不够的时候为止, 所减去的奇数个数就是N的开平方近似值

- N=25,则 N-1-3-5-7-9=0,共减了5个奇数, 再减11就不够减了.
- N=40,则 N-1-3-5-7-9-11=4, 共减了6个奇数, 再减13就不够减了

```assembly
.486
data segment use16
    num32 dd 99
data ends

code segment use16
assume cs:code, ds:data
    beg:mov ax, data
        mov ds, ax
        mov eax, num32
        mov ecx, 0

    last:mov edx, ecx
        add edx, edx
        inc edx
        sub eax, edx
        jc disp
        inc ecx
        jmp last

    disp:mov dl, cl
        add dl, '0'
        mov ah, 2
        int 21H
        mov ah, 4CH
        int 21H
code ends
end beg
```

## 5. 统计正负数

```assembly
.486
data segment use16
    dnum dw -10, 10, -20, 20, 5, 2, 1 ; 7 numebrs
    count_neg db 0
    count_pos db 0
data ends

code segment use16
assume cs:code, ds:data
    beg:mov ax, data
        mov ds, ax
        mov cx, 7
        mov dx, 0
        mov bx, offset dnum

    aga:mov ax, [bx]
        cmp ax, 0
        jl isneg
        inc count_pos
        jmp next
    isneg:inc count_neg

    next:add bx, 2
        loop aga

        mov dl, count_pos
        call disp
        mov dl, count_neg
        call disp
        mov ah, 4CH
        int 21H

    ;---------------------------
    disp proc
        mov ah, 2
        add dl, 30H
        int 21H
        mov dl, 0AH
        int 21H
        ret
    disp endp
    ;---------------------------
    
code ends
end beg
```



## 6. 复合分支

设NUMBER单元的数X以及数值N1、 N2均为单字节无符号数，请判断X的大小，并根据判断结果分别显示： N1<=X<=N2,或X<N1,或X>N2

```assembly
.486
data segment use16
	msg1 db 'N1 <= X <= N2 $'
	msg2 db 'X < N1 $'
	msg3 db 'X > N2 $'
	
	number db 199
	n1 equ 22
	n2 equ 88
data ends

code segment use16
	assume cs:code, ds:data
	beg:mov ax, data
        mov ds, ax
        mov dx, offset msg1 ; n1 < X < n2
        cmp number, n1
        jnc next
        mov dx, offset msg2 ; X < n1
        jmp disp
			
	next:cmp number, n2
        jc disp
        mov dx, offset msg3 ; X > n2
			
	disp:mov ah, 9
        int 21H
        mov ah, 4CH
        int 21H
code ends
end beg
```

