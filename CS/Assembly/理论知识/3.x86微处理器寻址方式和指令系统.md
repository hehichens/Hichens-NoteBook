## 1. x86微处理器的指令格式

### 1.1 指令编码格式

![](../pic/3_1_1.png)

### 1.2 指令书写格式

操作码+操作数

- 操作码（OP）：计算机要执行的操作
- 操作数（Operand）：指令的操作对象



#### 1.2.1 操作数

根据操作数存储位置分类

- 立即数：操作数存放在本条指令中
- 寄存器操作数：操作数存放在CPU的某个寄存器中
- 存储器操作数：操作数存放在存储器中



#### 1.2.2 指令类型

根据地址码的地址个数

- 零地址指令
- 一地址指令
- 二地址指令
- 三地址指令



## 2 x86处理器的寻址方式

### 2.1 非存储器操作数寻址

- 立即寻址
  - 操作数直接存放在指令中，作为指令一部分存放在代码段中
  - 主要用来给寄存器或存储器赋初值
- 寄存器寻址
  - 操作数存放在通用寄存器中
  - 特点：运算速度快



### 2.2 存储器操作数寻址

#### 2.1 基本概念

- 操作数存放在内存某个单元中，用**主存地址**表示

![](/Users/hichens/Hichens-NoteBook/CS/Assembly/pic/6.png)

- 80486采用**逻辑地址表示主存地址**

  - **段地址在默认的或着用段超越前缀指定的段寄存器中**
  - 指令中秩序给出操作数的**偏移地址（有效地址EA）**

- 有效地址（EA）：一个逻辑段中，某存储单元**相对于段首地址的地址位移量**

  - 组成成分：基址 + 变址*比例因子 + 位移量

  ![](/Users/hichens/Hichens-NoteBook/CS/Assembly/pic/3_2_2.png)

#### 2.2 寻址方式

- 直接寻址
  - 有效地址在指令中直接给出
  - 默认段寄存器是**DS寄存器**， 可使用段超前前缀改变
  - 用中括号包含有效地址，表达存储单元内容
  - 两个操作数中必须有一个是寄存器
- 寄存器间接寻址
  - 有效地址=BX/BP/SI/DI＋ 8/16位位移量
  - 段地址对应BX/BP/SI/DI寄存器默认是DS，对应BP寄存器默认是SS；可用段超越前缀改变
  - 要求事先把存储单元的有效地址写入规定的寄存器
- 寄存器相对寻址
  - 有效地址=BX/BP/SI/DI＋ 8/16位位移量
  - 段地址对应BX/BP/SI/DI寄存器默认是DS，对应BP寄存器默认是SS；可用段超越前缀改变
- 基址变址寻址
  - 有效地址=BX/BP＋SI/DI（基址寄存器+变址寄存器）
  - 段地址对应BX基址寄存器默认是DS，对应BP基址寄存器
    默认是SS；可用段超越前缀改变
- 相对基址变址寻址
  - 有效地址＝ BX/BP＋ SI/DI＋ 8/16位位移量
  - 段地址对应BX基址寄存器默认是DS，对应BP基址寄存器默认是SS；可用段超越前缀改变



## 3. x86微处理器的指令系统

### 3.1 数据传送类指令

#### 3.1.1 通用数据传送指令

- mov

```assembly
mov dst, src
```

- 把一个字节或字的操作数从源地址传送至目的地址
- 立即数->寄存器或主存 `mov dx, 200h`
- 寄存器->（段）寄存器或主存 `mov ax, bx`
- 主存->（段）寄存器 `mov dx, [bp]`
- 段寄存器->寄存器或主存 `mov ax, ds`

![](../pic/7.png)

**非法指令**

- 两个操作数不一致
- 两个操作数都是存储器（除了串操作，不允许两个操作数都是存储单元）
- 段寄存器的操作有一些限制
- 无法确定是字节量还是字量操作

![](../pic/8.png)



**注意**

![](../pic/9.png)

```assembly
movsx dst, src
;将SRC的符号位向高位扩展，使其与目标操作数字长相同，再送到DST，而SRC保持不变

movzx dst, src
;将SRC的高位用0补充，使其与目标操作数字长相同，再送到DST，而SRC保持不变。
```



```assembly
lea reg, src
```

- REG <- EA 把源操作数的有效地址送到指定的寄存器
- src 为内存操作数
- reg 为 16位或32位寄存器（除段寄存器外）



```assembly
lds/les/lfs/lgs/lss reg, src
;将源操作数高16位送隐含的目标寄存器
```



```assembly
lahf
```

- 标志寄存器传送指令
- 将标志寄存器低8位送ah指令



```assembly
sahf
```

- （ PSW的低位字节）<-  (AH)



```assembly
xchg OPR1, OPR2
```

- (OPR1 ) <=> (OPR2)
- OPR1与OPR2须是等长操作数, 且PR1,OPR2必须有一个是寄存器
- 执行结果不影响标志位
- 段寄存器不能作为xchg的操作数



```assembly
bswap reg32
```

- 字节交换指令
- 将32位REG的位31～位24与 位7～位0交换，位23～位16与位15～位8交换





```assembly
xlat table_name
```

- 查表指令（换码）
- 把一种码转换为另一种代码
- 使用：
  - 建立表格，将表格首地址预先存入bx或edx
  - 将要转换的代码与表格首地址的偏移量存入al
  - 执行换码指令  `DS:[BX+AL]  -> AL`



#### 3.1.2 堆栈操作指令

```assembly
push src
```

- 进栈指令
- 执行时， 首先调整堆栈指针，然后把源操作数压栈
- 执行操作：
  - 16位：`(SP) <- (SP)-2   ((SP)+1,(SP)) <-(SRC)`
  - 32位：`(ESP) <- (ESP)-4 ((ESP)+3 ~ (ESP))<-(SRC)`

- 若操作数不是直接寻址，则必须用PTR运算符来说明其属性。 `PUSH WORD PTR [BX]`



```assembly
pop dst
```

- 出栈指令
- 先将栈顶弹出2个或4个字节，送目标操作数，然后调整堆栈指针。
- 执行操作
  - 16位：`((SP)+1,(SP)) ->(DST) (SP) <-(SP) + 2`
  - 32位：`(ESP)+3~(SP)) -> (DST) (ESP) <- (ESP) +4`
- 例：` POP WORD PTR [BX]`



**堆栈操作特点**

- 堆栈操作的单位是**字**
- 堆栈空间：栈底（高地址单元）、栈顶（低地址单元）
- 栈底固定不变，栈顶随数据进出栈变化，通常用SP来指出栈顶的地址
- 字量数据压栈出栈时，都是低地址字节送低字节，高地址字节送高字节
- 堆栈操作遵循先进后出，但可用存储器寻址方式随机存取堆栈的数据
- 堆栈段作用：
  - 临时存放数据
  - 传递参数
  - 保存和回复寄存器



```assembly
pushf ; flags标志位入栈

popf ;flags标志位出栈

pushfd ; flags标志位入栈

popdf ; eflags 出栈

pusha ; 16位通用寄存器入栈

popa ; 16位通用寄存器出栈

pushd ; 32位通用寄存器入栈

popad ; 32位通用寄存器出栈
```



### 3.2 算术运算类指令

```assembly
; 加法
add dest, src ; dest <- dest + src
adc dest, src; desc <- dest + src + CF
inc reg/mem; reg/mem <- reg/mem + 1
```

```assembly
; 减法
sub dest, src ; dest <- dest - src
sbb dest, src ; dest <- dest - src - CF
dec reg/mem ; reg/mem <- reg/mem - 1
neg reg/mem ; reg/mem <- 0－ reg/mem
```



```assembly
cmp dst, src ; dst - src
```

- 执行的结果不回送DST, 而是根据结果去影响标志位：
  CF、 OF、 SF、 ZF、 PF、 AF
- CMP常用于转移指令之前



```assembly
cmpxchg dst, src; 
```

- 比较并交换指令
- 将DST与AL/AX/EAX比较， 相等,则将SRC送DST;若不等,则将DST送AL/AX/EAX



```assembly
mul src ; 无符号乘法
```

- 乘数和被乘数必须是等长的无符号二进制数，乘积为双倍长
- **被乘数默认保存在累加器中（AL/AX/EAX）**
- 执行操作
  - 字节操作：(AX) <- (AL) * (SRC)
  - 字操作：(DX,AX) <- (AX) * (SRC)
  - 双字操作：(EDX,EAX) <- (EAX) * (SRC)
- 目标操作数必须是累加器AL、AX、EAX， 源操作数是除立即数之外的寻址方式
- 影响CF、OF标志位



```assembly
imul ; 带符号乘法
```

- 影响标志位：CF、OF
- 如果乘积的高一半是低一半的符号扩展则CF=OF = 0，否则 CF = OF = 1
- 执行操作：同无符号乘法
- 目标操作数必须是累加器AL、AX、EAX， 源操作数是除立即数之外的寻址方式



```assembly
div src
```

- 被除数应是除数的双倍字长，被除数放在默认寄存器
- 操作：
  - 字节操作：
    - 16 位被除数放在AX中， 8位除数为源操作数
    - 结果的8位商在AL中， 8位的余数在AH中
  - 字操作：
    - 32 位被除数在DX,AX中， 16位除数为源操作数
    - 结果的16位商在AX中， 16位的余数在DX中
  - 双字操作：
    - 64 位被除数在EDX,EAX中， 32位除数为源操作数
    - 结果的32位商在EAX中， 32位的余数在EDX中
- 执行DIV，运算后对标志位无确定影响，都没有意义
- 商超过规定的范围， 去执行0型中断



```assembly
idiv src ;
```

- 与DIV相同，但除数、被除数和商值都是有符号补码数
- 若被除数与除数等长时， 须先将被除数扩展。数的大小不变， 仅将数的符号位扩展。
- 操作：同 `div`



符号拓展指令

```assembly
cbw ; 字节->字，将AL的符号位拓展到AH

cwd ; 字->双字，将AX的符号位拓展到DX

cdq ; 双字->四字，EAX的符号位拓展到EDX

```

![](../pic/10.png)

```assembly
; X * Y 字操作：(DX,AX) <- (AX) * (SRC)
mov ax, X
imul Y ;
mov cs, ax
mov bx, dx

; +Z
mov ax, Z
cwd ; 字->双字，将AX的符号位拓展到DX
add cx, ax ; 
adc bx, dx ; 

; - 540
sub cx, 540 ;
sbb bx, 0 ;

; V - 
mov ax, V
cwd
sub ax, cx
sub dx, bx
div x
; 32 位被除数在DX,AX中， 16位除数为源操作数
; 结果的16位商在AX中， 16位的余数在DX中
```



BCD码调整依据

- 出现非法编码
- AF=1 or CF=1

```assembly
daa 
```

- 压缩BCD码加法调整指令
- 针对AL中的两个组合十进制数之和进行修改，得到正确的组合十进制数
- 使用这条指令之前必须执行ADD或ADC指令将两个压缩的BCD码相加，并且把结果存放在AL寄存器中
- 调整方法：
  - 如果AF=1或AL的低四位大于9，则AL的寄存器内容加06H且使AF = 1
  - 如果CF=1或AL的高四位大于9 ，则AH的寄存器内容加60H且使CF = 1
  - DAA 执行后影响A、 C、 P、 S、 Z标志， 对OF未定义

![](../pic/11.png)



```assembly
das 
```

- DAS压缩BCD码减法调整指令

- 针对AL中两个组合BCD之差进行修改，得到正确的组合十进制数表示的差值

- 使用这条指令之前必须执行SUB或SBB指令将两个压缩的BCD码
  相减，并且把结果存放在AL寄存器中

- 调整方法：

  - 如果AF=1 或者AL的低四位大于9，则AL的寄存器内容减06H且AF=1
  - 如果CF=1 或者AL的高四位大于9 ，则AH的寄存器内容减60H且CF=1
  - DAS执行后，影响A、 C、 P、 S、 Z标志位，对OF无定义

  

```assembly
aaa
```

- 未组合十进制加法调整指令
- 将存放在AL中的二个未组合十进制数之和进行调整， 从而在AH中得到十位的BCD码， AL中得到个位BCD码
- AAA一般紧跟在ADD或ADC之后， 影响标志A， C



```assembly
aas ; 未组合十进制数减法调整指令
aam ; 未组合十进制数乘法调整指令
aad ; 未组合十进制数除之前调整指令

```



### 3.3 转移和调用指令

用于控制指令流程的指令：

- 转移
- 循环
- 过程调用
- 中断调用

按转移条件分： 

- 无条件转移

- 有条件转移

按转移的范围分：
- 段内转移
- 段间转移

按获取地址的方法分：
- 直接转移和
- 间接转移



#### 3.3.1 无条件转移指令

```assembly
jmp
```

- 无条件转移指令

- 功能:

  - 执行指定标号处的指令
  - 执行结果不影响标志位

  

**转移地址寻址方式**

CS:IP 控制程序执行顺序

- 段内转移，指令只修改IP内容
- 段间转移，指令须修改CS、 IP内容



```assembly
; 段内直接转移
jmp 标号
jmp short 标号
```

- short：指令偏移量为8位，允许转移值的范围为－ 128～+127
- 不含SHORT的指令，其转移范围可覆盖整个逻辑段



```assembly
; 段内间接转移
jmp 寄存器操作数 ; IP <- (EA)
jmp 内存操作数
```

- 寄存器、 内存单元存放的是有效地址
- 间接是指当CPU执行指令时, 将寄存器或内存单元内的有效地址写入IP或EIP, 从而实现转移



```assembly
; 段间直接转移
jmp 标号
; IP <- 跳转的EA
; CS <- 跳转的段地址
```

- 模块化程序设计中, 从一个模块转移到另一个模块需执行段间转移指令
- 



```assembly
; 段间间接转移
jmp 内存操作数 
; IP <- （EA）
; CS <- （EA+2）
```

- 在实模式下，段间间接转移指令将段地址和偏移地址送给CS和IP



#### 3.3.2 条件转移指令

- 按标志位当前状态转移
- 无符号数条件转移 （ “ A” 、“ B” ）
- 有符号数条件转移 （“ G” 、“ L” ）
- 循环控制转移

##### （1）判断单个标志的条件转移指令

![](../pic/12.png)



#####  (2) 判断无符号数大小的条件转移指令

A:大于, B:小于, E:等于

![](../pic/13.png)

 

##### （ 3）判断有符号数大小的条件转移指令

G:大于, L:小于, E:等于

![](../pic/14.png)



#### 3.3.3 循环控制指令

```

```

