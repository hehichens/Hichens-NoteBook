## 1. x86微处理器的指令格式

### 1.1 指令编码格式

![](../pic/3_1_1.png)

### 1.2 指令书写格式

操作码+操作数

- 操作码（OP）：计算机要执行的操作
- 操作数（Operand）：指令的操作对象



#### 1.2.1 操作数

根据操作数存储位置分类

- 立即数：操作数存放在本条指令中
- 寄存器操作数：操作数存放在CPU的某个寄存器中
- 存储器操作数：操作数存放在存储器中



#### 1.2.2 指令类型

根据地址码的地址个数

- 零地址指令
- 一地址指令
- 二地址指令
- 三地址指令



## 2 x86处理器的寻址方式

### 2.1 非存储器操作数寻址

- 立即寻址
  - 操作数直接存放在指令中，作为指令一部分存放在代码段中
  - 主要用来给寄存器或存储器赋初值
- 寄存器寻址
  - 操作数存放在通用寄存器中
  - 特点：运算速度快



### 2.2 存储器操作数寻址

#### 2.1 基本概念

- 操作数存放在内存某个单元中，用**主存地址**表示

![](/Users/hichens/Hichens-NoteBook/CS/Assembly/pic/6.png)

- 80486采用**逻辑地址表示主存地址**

  - **段地址在默认的或着用段超越前缀指定的段寄存器中**
  - 指令中秩序给出操作数的**偏移地址（有效地址EA）**

- 有效地址（EA）：一个逻辑段中，某存储单元**相对于段首地址的地址位移量**

  - 组成成分：基址 + 变址*比例因子 + 位移量

  ![](/Users/hichens/Hichens-NoteBook/CS/Assembly/pic/3_2_2.png)

#### 2.2 寻址方式

- 直接寻址
  - 有效地址在指令中直接给出
  - 默认段寄存器是**DS寄存器**， 可使用段超前前缀改变
  - 用中括号包含有效地址，表达存储单元内容
  - 两个操作数中必须有一个是寄存器
- 寄存器间接寻址
  - 有效地址=BX/BP/SI/DI＋ 8/16位位移量
  - 段地址对应BX/BP/SI/DI寄存器默认是DS，对应BP寄存器默认是SS；可用段超越前缀改变
  - 要求事先把存储单元的有效地址写入规定的寄存器
- 寄存器相对寻址
  - 有效地址=BX/BP/SI/DI＋ 8/16位位移量
  - 段地址对应BX/BP/SI/DI寄存器默认是DS，对应BP寄存器默认是SS；可用段超越前缀改变
- 基址变址寻址
  - 有效地址=BX/BP＋SI/DI（基址寄存器+变址寄存器）
  - 段地址对应BX基址寄存器默认是DS，对应BP基址寄存器
    默认是SS；可用段超越前缀改变
- 相对基址变址寻址
  - 有效地址＝ BX/BP＋ SI/DI＋ 8/16位位移量
  - 段地址对应BX基址寄存器默认是DS，对应BP基址寄存器默认是SS；可用段超越前缀改变



## 3. x86微处理器的指令系统

### 3.1 数据传送类指令

#### 3.1.1 通用数据传送指令

- mov

```assembly
mov dst, src
```

- 把一个字节或字的操作数从源地址传送至目的地址
- 立即数->寄存器或主存 `mov dx, 200h`
- 寄存器->（段）寄存器或主存 `mov ax, bx`
- 主存->（段）寄存器 `mov dx, [bp]`
- 段寄存器->寄存器或主存 `mov ax, ds`

![](../pic/7.png)

**非法指令**

- 两个操作数不一致
- 两个操作数都是存储器（除了串操作，不允许两个操作数都是存储单元）
- 段寄存器的操作有一些限制
- 无法确定是字节量还是字量操作

![](../pic/8.png)



**注意**

![](../pic/9.png)

```assembly
movsx dst, src
;将SRC的符号位向高位扩展，使其与目标操作数字长相同，再送到DST，而SRC保持不变

movzx dst, src
;将SRC的高位用0补充，使其与目标操作数字长相同，再送到DST，而SRC保持不变。
```



```assembly
lea reg, src
```

- REG <- EA 把源操作数的有效地址送到指定的寄存器
- src 为内存操作数
- reg 为 16位或32位寄存器（除段寄存器外）



```assembly
lds/les/lfs/lgs/lss reg, src
;将源操作数高16位送隐含的目标寄存器
```



```assembly
lahf
```

- 标志寄存器传送指令
- 将标志寄存器低8位送ah指令



```assembly
sahf
```

- （ PSW的低位字节）<-  (AH)



```assembly
xchg OPR1, OPR2
```

- (OPR1 ) <=> (OPR2)
- OPR1与OPR2须是等长操作数, 且PR1,OPR2必须有一个是寄存器
- 执行结果不影响标志位
- 段寄存器不能作为xchg的操作数



```assembly
bswap reg32
```

- 字节交换指令
- 将32位REG的位31～位24与 位7～位0交换，位23～位16与位15～位8交换





```assembly
xlat table_name
```

- 查表指令（换码）
- 把一种码转换为另一种代码
- 使用：
  - 建立表格，将表格首地址预先存入bx或edx
  - 将要转换的代码与表格首地址的偏移量存入al
  - 执行换码指令  `DS:[BX+AL]  -> AL`



#### 3.1.2 堆栈操作指令

```assembly
push src
```

- 进栈指令
- 执行时， 首先调整堆栈指针，然后把源操作数压栈
- 执行操作：
  - 16位：`(SP) <- (SP)-2   ((SP)+1,(SP)) <-(SRC)`
  - 32位：`(ESP) <- (ESP)-4 ((ESP)+3 ~ (ESP))<-(SRC)`

- 若操作数不是直接寻址，则必须用PTR运算符来说明其属性。 `PUSH WORD PTR [BX]`



```assembly
pop dst
```

- 出栈指令
- 先将栈顶弹出2个或4个字节，送目标操作数，然后调整堆栈指针。
- 执行操作
  - 16位：`((SP)+1,(SP)) ->(DST) (SP) <-(SP) + 2`
  - 32位：`(ESP)+3~(SP)) -> (DST) (ESP) <- (ESP) +4`
- 例：` POP WORD PTR [BX]`



**堆栈操作特点**

- 堆栈操作的单位是**字**
- 堆栈空间：栈底（高地址单元）、栈顶（低地址单元）
- 栈底固定不变，栈顶随数据进出栈变化，通常用SP来指出栈顶的地址
- 字量数据压栈出栈时，都是低地址字节送低字节，高地址字节送高字节
- 堆栈操作遵循先进后出，但可用存储器寻址方式随机存取堆栈的数据
- 堆栈段作用：
  - 临时存放数据
  - 传递参数
  - 保存和回复寄存器



