## 1. 汇编源程序的语句类型

指令

- 指令性语句、可执行语句、符号指令
- 指令性指令、说明性语句、伪指令

格式

- 指令性语句
- 指示性语句



## 2. 宏汇编基本语法

### 2.1 标号、变量和常量

#### 2.1.1. 标号和变量

- 标号：
  - 指令地址
  - 定义在CS中
  - 为转移指令提供目标
- 变量：
  - 内存操作数的地址
  - 定义在DS、ES、SS中

标号和变量的三个属性

- 段属性：`ESG`求段基址
- 偏移属性：`OFFSET`求有效地址
- 类型属性：
  - DB 字节型
  - DW 字型
  - DD 双字型
  - DQ 四字型
  - DT 五字型

标号类型

- `NEAR`： **段内**转移地址的目标地址
- `FAR`：**段间**转移地址的目标地址

#### 2.1.2 常量

- 立即数
  - 汇编后转成二进制补码
- 字符串常数
  - 用 ‘ ’括起来
  - 汇编后转成ASCII码
- 符号常数
  - 使用一个标志符表达一个数值
  - 常用`EQU`或`=`定义
  - 不能重复定义符号名

### 2.2 符号运算符

### 2.2.1 数值运算符

- 算术运算符
  - +、-、*、/、MOD
- 逻辑运算符
  - 逻辑：NOT、AND、OR、XOR
  - 截断：HIGH（高8位）、LOW（低8位）
- 关系运算符
  - EQ、NE、LE、GE、LT、GT

### 2.2.2 类型运算符

- `PTR`
  - `BYTE/WORD/DOWRD/FAR/NEAR + PRT + 转移地址标号/过程名/内存操作数`
  - 修改或确定操作数类型
- `LABEL`
  - `Name + LABEL + BYTE/WORD/DOWRD/FAR/NEAR`



### 2.2.3 属性运算符

- `SEG`

  - 求逻辑段、变量、标号的`段基址`
- `OFFSET`

  - 取变量、标号的偏移地址
- `TYPE`

  - 返回变量、标号的类型
- `$`
  - 使用$引用地址计数器的值
  - $代表当前的偏移地址值
- LENGTH
  - 对于DUP定义的变量，返回分配的单元数
- SIZE
  - 变量的字节数，等价于`TYPE * LENGTH`



**地址操作符**

| []     | 存储器地址指针                 |
| ------ | ------------------------------ |
| $      | 当前偏移地址                   |
| :      | 段前缀、采用指定的段地址寄存器 |
| OFFSET | 名字或标号的偏移地址           |
| SEG    | 名字或标号的段地址             |



## 3. 数据定义伪指令

### 3.1 变量定义

1. 字符串：`Message DB ‘HELLO’`
2. ?：保留存储空间但不存入数据：`ABC DB 0,?,?,?,0`
3. 重复使用DUP：`ARRAY DB 2 DUP(0,1,2,?)`
4. 嵌套使用DUP：`ARRAY DB 100 DUP(0,2 DUP(1,2),0,3)`
5. 取符号地址的偏移地址或整个地址

### 3.2 变量的内存存放情况

- 在变量名地址开始处依次存入各项值
- 同时有几个定义变量语句时，按照**由低到高**地址给每个变量语句表达式分配存储单元的规则存放

### 3.3 标号定义

- 隐式定义
  - 标号后加`:`: `L1:MOV AX,BX`
- 显式定义
  - `LABEL`
  - `EQU THIS`

### 3.4 变量定位

- 汇编程序按指令先后依次分配存储空间，按照段定义伪指令规定的边界定位属性确定每个逻辑段的起始位置
- `ORG`控制数据或代码所在的偏移地址
- `ORG`将当前偏移地址指针指向参数表达的偏移地址
- `$`表示当前偏移地址

### 3.5 伪操作

- `EVEN`：使下一个字节地址成为偶数
- `ALIGN`：保证双字数组边界从4的倍数开始
- `RADIX`：修改数制

## 

## 4. 宏汇编语句基本语句

- 用**方式选择**伪指令说明执行该程序的CPU类型;
- 用**段定义语句**定义每一个逻辑段;
- 用**过程定义**语句定义每一个子程序;
- 用`ASSUME`语句说明段约定;
- 用**汇编结束语句**说明源程序结束.










